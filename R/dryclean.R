#' @importFrom data.table setkeyv
#' @import GenomicRanges
#' @import rsvd
#' @importFrom MASS ginv
#' @import gUtils


##############################
## dryclean R6 object
##############################
#' @name dryclean
#' @title dryclean
#' @description dryclean R6 class storing all methods and values necessary for "drycleaning"
#' @details Add more details 
#'
#' @field .normal.table.path
#' @description Character path to data.table containing two columns "sample" and "normal_cov". See manual for details.
#'
#' @field .normal.table
#' @description data.table containing two columns "sample" and "normal_cov". See manual for details.
#'
#' @field .pon.path
#' @description Character path to PON/detergent
#'
#' @field .pon
#' @description PON/detergent object; can be passed to an object or generated using normal samples by \code{prepare_detergent()} method
#'
#' @field .cov.path
#' @description Character path to GRanges object containig the GC corrected cov data outputed from fragCounter. Needs metadata with header "reads.corrected"
#'
#' @field .drycleaned.cov
#' @description GRanges object containing drycleaned cov data
#'
#' @method initialize(normal_table_path = NA, pon_path = NA, cov_path)
#' @description Initialized dryclean object with given paths to normal table, PON and cov
#'
#' @param normal_table_path Character path to data.table containing two columns "sample" and "normal_cov". See manual for details
#' 
#' @param pon_path Character path to PON/detergent
#' @details Can either point to the existing PON or point to the directory where the user wants to save the PON generated by \code{prepare_detergent(save.pon = TRUE)} method
#' 
#' @param cov_path Character path to GRanges object containig the GC corrected cov data outputed from fragCounter. Needs metadata with header "reads.corrected"
#'
#' @method prepare_detergent(use.all = TRUE, choose.randomly = FALSE, choose.by.clustering = FALSE, number.of.samples = 50, save.pon = FALSE, verbose = TRUE, num.cores = 1, tolerance = 0.0001, is.human = TRUE, build = "hg19", field = "reads.corrected", PAR.file = NULL, balance = TRUE, infer.germline = TRUE, signal.thresh = 0.3, pct.thresh = 0.80, wgs = TRUE, target_resolution = 1000, nochr = TRUE, all.chr = c(as.character(1:22), "X")
#' @description This is the frist stage and involves preparing the Panel of Normals (PON)
#' that will be used for online decomposition. Author: Aditya Deshpande
#' @details This function takes in gRanges outputs from fragCounter and extracts GC corrected
#' read count data and carries rPCA decomposition on the matrix thus created. The normal samples used to form the PON can be selected randomly or by clustering the genomic bacground or all samples can be used.
#' 
#' @param use.all boolean (default == TRUE). If all normal samples are to be used for creating PON.
#' 
#' @param choose.randomly boolean (default == FALSE). If a random subset of normal samples are to be used for creating PON.
#' 
#' @param choose.by.clustering boolean (default == FALSE). Clusters normal samples based on the genomic background and takes a random sample from within the clusters.
#' 
#' @param number.of.samples interger (default == 50). If choose.by.clustering == TRUE, this is the number of clusters at which to cut tree.
#'
#' @param tolerance numeric (default == 0.0001). Tolerance for error for batch rPCA. We suggest keeping this value.
#' 
#' @param save.pon boolean (default == FALSE). If PON needs to be saved.
#' 
#' @param num.cores interger (default == 1). Number of cores to use for parallelization.
#'
#' @param verbose boolean (default == TRUE). Outputs progress.
#'
#' @param is.human boolean (default == TRUE). Organism type.
#' 
#' @param build genome build to define PAR region in chromosome X.
#'
#' @param field character (default == "reads.corrected"). Field to use for processing.
#'
#' @param PAR.file this is a GRanges with the boundaries of PAR region in X chr.
#'
#' @param balance Boolean (default == TRUE) experimental variable to take into consideration 1 copy of X chr in male sample
#'
#' @param infer.germline use the L matrix to infer germline events.
#'
#' @param signal.thresh numeric (default == 0.5). This is the threshold to be used to identify an amplification (markers with signal intensity > 0.5) or deletions (markers with signal intensity < -0.5) in log space from dryclean outputs.
#'
#' @param pct.thresh numeric (default == 0.98). Proportion of samples in which a given marker is free of germline event.
#'
#' @param wgs boolean for whether whole genome is being used
#'
#' @param target_resolution numeric (default == 1e3) resolution at which to conduct analyses
#'
#' @param nochr logical (default = TRUE) remove chr prefix
#'
#' @param all.chr list(default = c(as.character(1:22), "X")) list of chromosomes
#'
#'
#' @method start_wash_cycle(mc.cores = 1, verbose = TRUE, whole_genome = TRUE, use.blacklist = FALSE, chr = NA, germline.filter = FALSE, germline.file = NA, field = "reads.corrected", is.human = TRUE, all.chr = c(as.character(1:22), "X"))
#' @description Function begins the online rPCA process. Use this function if you performed batch rPCA on samples as whole without dividing into chromosomes. For exomes and whole genomes where number of normal samples are small (<=100). Author: Aditya Deshpande 
#' @details The function begins the online rPCA process. It is the wrapper that takes in GRanges and outputs GRanges with decomposition 
#' 
#' @param mc.cores interger (default == 1). Number of cores to use for parallelization.
#' 
#' @param detergent.pon.path string. Path to pon/detergent genrated using normal samples.
#' 
#' @param whole_genome boolean (default = TRUE). For this function always set this parameter to TRUE.
#' 
#' @param use.blacklist boolean (default = FALSE). Whether to exclude off-target markers in case of Exomes or targeted sequqnecing. If set to TRUE, needs a GRange marking if each marker is set to be excluded or not.
#'
#' @param germline.filter boolean (default == FALSE). If germline markers need to be removed from decomposition.
#'
#' @param germline.file character (default == NA). Path to file with germline markers.
#' 
#' @param verbose boolean (default == TRUE). Outputs progress.
#' 
#' @param is.human boolean (default == TRUE). Organism type.
#' 
#' @param field character (default == "reads.corrected"). Field to use for processing.
#' 
#' @param chr integer (default == NA). Depricated. Can be used to decompose a single chromosome.
#'
#' @param all.chr list(default = c(as.character(1:22), "X")) list of chromosomes
#'
#' @method get_drycleaned_cov()
#' @description Function returns the 'drycleaned' GRanges object
#'
#' @return The 'drycleaned' GRanges object from cov input
#' 
#' @method get_normal_table_path()
#' @description Function returns the path to the normal table
#'
#' @return Path to the normal table
#' 
#' @method get_normal_table()
#' @description Function returns the normal table
#'
#' @return Normal table
#' 
#' @method get_pon_path()
#' @description Function returns the path to the PON
#'
#' @return Path to the PON
#' 
#' @method get_pon()
#' @description Function returns the PON
#'
#' @return PON
#' 
#' @method get_cov_path()
#' @description Function returns the path to the coverage file
#'
#' @return Path to the coverage file
#'
#' @export
#' 
#' @author Aditya Deshpande <Addy's email>, Sebastian Brylka <sebastian.brylka@nyulangone.org> 


dryclean <- R6::R6Class("dryclean",
    private = list(
    normal.table.path = NULL,
    normal.table = NULL,
    pon.path = NULL,
    pon = NULL,
    cov.path = NULL,
    drycleaned.cov = NULL
  ),
  
  public = list(
    initialize = function(normal_table_path = NA, pon_path = NA, cov_path) {
      
      private$normal.table.path = normal_table_path
      private$pon.path = pon_path
      
      if(is.na(normal_table_path) & is.na(pon_path)){
        stop("Enter normal table path or PON path")
      }

      if(!is.na(normal_table_path)){
        private$normal.table = readRDS(normal_table_path)
      }

      if(is.na(normal_table_path) & !is.na(pon_path)){
        if (file.exists(private$pon.path)){
          private$pon = readRDS(private$pon.path)
        } else {
          message("Warning: PON data file not found or is invalid.")
        }
        
      }

      private$cov.path = cov_path

    },
    
    prepare_detergent = function(use.all = TRUE, choose.randomly = FALSE, choose.by.clustering = FALSE, number.of.samples = 50, save.pon = FALSE, verbose = TRUE, num.cores = 1, tolerance = 0.0001, is.human = TRUE, build = "hg19", field = "reads.corrected", PAR.file = NULL, balance = TRUE, infer.germline = TRUE, signal.thresh = 0.3, pct.thresh = 0.80, wgs = TRUE, target_resolution = 1000, nochr = TRUE, all.chr = c(as.character(1:22), "X")){
      
      source("~/git/dryclean/R/rrpca.mod2.R")
      source("~/git/dryclean/R/helper_functions.R")
      
      normal.table.path = private$normal.table.path
      path.to.save = private$pon.path

      if (is.na(normal.table.path)){
        stop("Need a table with paths to normal samples to create a PON")
      }

      if (is.na(path.to.save) & save.pon == TRUE){
        stop("Need a path to save decomposed PON")
      }

      if (!is.na(normal.table.path) & !is.na(path.to.save) & save.pon == TRUE){
        message(paste0("WARNING: Creating new PON and saving it at ",path.to.save))
        var = readline(prompt = "Would you like to proceed? Leave the input empty and press Enter to continue, or enter any value to stop ")
        if (var!=""){
          stop("Preparing detergent has been stopped")
        }

      }

      if (verbose){
        message("Starting the preparation of Panel of Normal samples a.k.a detergent")
      }

      normal.table = readRDS(normal.table.path)
      setkeyv(normal.table, "sample")

      num.samp = nrow(normal.table)

      if (verbose){
        message(paste0(num.samp, " samples available"))
      }

      if (use.all & choose.randomly | use.all & choose.by.clustering | choose.randomly & choose.by.clustering | use.all & choose.randomly & choose.by.clustering){
        stop("only one of use.all, choose.randomly, choose.by.clustering can be set to TRUE. Rectify and restart")
      }
      
      if (nochr) {
        template = generate_template_new(cov = gUtils::gr.nochr(readRDS(normal.table[1]$normal_cov)), wgs = wgs, target_resolution = target_resolution, this.field = field, nochr = nochr, all.chr = all.chr)
      } else {
        template = generate_template_new(cov = readRDS(normal.table[1]$normal_cov), wgs = wgs, target_resolution = target_resolution, this.field = field, nochr = nochr, all.chr = all.chr)
      }

      if (choose.randomly){
        if (verbose){
          message(paste0("Selecting ", number.of.samples, " normal samples randomly"))
        }
        set.seed(12)
        samp.final = sample(1:num.samp, number.of.samples)
        samp.final = normal.table[samp.final]
        setkey(samp.final, "sample")
      }

      if (choose.by.clustering){

        if (verbose){
          message("Starting the clustering")
        }

        mat.small = mclapply(normal.table[, sample], function(nm){
          this.cov = tryCatch(readRDS(normal.table[nm, normal_cov]), error = function(e) NULL)
          if (!is.null(this.cov)){
            if (nochr) {
              this.cov = gUtils::gr.nochr(this.cov)
            }
            ## this.cov = standardize_coverage(gr.nochr(this.cov), template = template, wgs = wgs, target_resolution = target_resolution, this.field = field)
            this.cov = this.cov[, field] %>% gr2dt() %>% setnames(., field, "signal")
            ## reads = this.cov[seqnames == "22", .(seqnames, signal)]
            reads = this.cov[seqnames == seqnames[1], .(seqnames, signal)]
            reads[, median.chr := median(.SD$signal, na.rm = T), by = seqnames]
            reads[is.na(signal), signal := median.chr]
            min.cov = min(reads[signal > 0]$signal, na.rm = T)
            reads[signal == 0, signal := min.cov]
            reads[signal < 0, signal := min.cov]
            reads = log(reads[, .(signal)])
            reads = transpose(reads)
            reads = cbind(reads, nm)
          } ## else {reads = data.table(NA)}
          return(reads)}, mc.cores = num.cores)

        gc()

        mat.sub = rbindlist(mat.small, fill = T)
        mat.sub = na.omit(mat.sub)
        ix = ncol(mat.sub)
        samp.names = mat.sub[, ..ix]
        mat.sub.t = transpose(mat.sub[, 1:(ncol(mat.sub) - 1)])
        rm(mat.sub)
        gc()

        if (verbose){
          message("Starting decomposition on a small section of genome")
        }

        mat.sub.t = as.matrix(mat.sub.t)
        gc()

        rpca.mat = rrpca.mod(mat.sub.t, tol = tolerance, trace = F)

        rm(mat.sub.t)
        gc()

        if (verbose){
          message("Starting clustering")
        }

        l.mat = rpca.mat$L

        rm(rpca.mat)
        gc()

        l.mat = t(l.mat)
        rownames(l.mat) = samp.names$nm
        clust.out = hclust(dist(l.mat))

        memb = cutree(clust.out, k = number.of.samples)
        memb = setDT(as.data.frame(data.matrix(memb)), keep.rownames = T)

        set.seed(12)
        samp.selected = memb[, .SD[sample(1:.N, 1)], by = V1]$rn
        samp.final = normal.table[samp.selected]
        setkey(samp.final, "sample")
      }

      if (use.all){
        if (verbose){
          message("Using all samples")
        }

        samp.final = normal.table
        setkey(samp.final, "sample")
      }


      if (is.null(PAR.file)){
        if (build == "hg38") {
          message("PAR file not provided, using hg38 default. If this is not the correct build, please provide a GRange object delineating for corresponding build")
          par.path = system.file("extdata", "PAR_hg38.rds", package = 'dryclean')
        } else {
          message("PAR file not provided, using hg19 default. If this is not the correct build, please provide a GRange object delineating for corresponding build")
          par.path = system.file("extdata", "PAR_hg19.rds", package = 'dryclean')
        }
        par.gr = readRDS(par.path)
      } else {par.gr = readRDS(PAR.file)}

      message("PAR read")

      samp.final[, file.available := file.exists(normal_cov)]

      message("Checking for existence of files")

      samp.final = samp.final[file.available == TRUE]

      message(paste0(nrow(samp.final), " files present"))

      mat.n = pbmcapply::pbmclapply(samp.final[, sample], function(nm, all.chr){
        this.cov = tryCatch(readRDS(samp.final[sample == nm, normal_cov]), error = function(e) NULL)
        if (!is.null(this.cov)){
          ## this.cov = standardize_coverage(cov = gr.nochr(this.cov), template = template, wgs = wgs, target_resolution = target_resolution, this.field = field)
          if (nochr) {
            this.cov = gr.nochr(this.cov)
          }
          this.cov = this.cov %Q% (seqnames %in% all.chr)
          this.cov = sortSeqlevels(this.cov)
          this.cov = sort(this.cov)
          this.cov = this.cov[, field] %>% gr2dt() %>% setnames(., field, "signal.org")
          if (balance){
            this.cov[, median.idx := .GRP, by = seqnames]
            this.cov$mt = suppressWarnings(gr.match(dt2gr(this.cov), par.gr))
            this.cov[, median.idx := ifelse(is.na(mt), median.idx, mt+24)]
            this.cov[, median.chr := median(signal.org, na.rm = T), by = median.idx]
            this.cov[, signal := ifelse(seqnames != "X", signal.org,
                                        ifelse(median.chr == 0, 1, signal.org/median.chr))]
          } else {
            this.cov[, signal := signal.org]
            this.cov[, median.chr := median(signal.org, na.rm = T)]
          }
          reads = this.cov[, .(seqnames, signal, median.chr)]
          reads[is.na(signal), signal := median.chr]
          min.cov = min(reads[signal > 0]$signal, na.rm = T)
          reads[is.infinite(signal), signal := min.cov]
          reads[signal == 0, signal := min.cov]
          reads[signal < 0, signal := min.cov]
          reads[, signal := log(signal)]
          reads = reads[, .(signal)]
          if (!any(is.infinite(reads$signal))){
            reads = transpose(reads)
            return(reads)
          }
        }
      }, all.chr, mc.cores = num.cores)
      gc()
      mat.bind = rbindlist(mat.n, fill = T)

      mat.bind.t = transpose(mat.bind)

      rm(mat.bind)
      gc()

      if (verbose){
        message("Starting decomposition")
      }

      mat.bind.t = as.matrix(mat.bind.t)
      gc()

      detergent = rrpca.mod(mat.bind.t, trace = F, tol = tolerance)

      rm(mat.bind.t)
      gc()

      rsvd.L.burnin = rsvd(detergent$L, k = detergent$k)
      detergent$U.hat = rsvd.L.burnin$u
      detergent$V.hat = t(rsvd.L.burnin$v)
      detergent$sigma.hat = rsvd.L.burnin$d
      ##browser()
      ##this.template = readRDS(samp.final[1]$normal_cov)
      ##this.template = sortSeqlevels(this.template)
      ##this.template = sort(this.template)
      ##
      detergent$template = template

      if (infer.germline){
        this.s = as.data.table(detergent$S)
        gc()
        for(col in names(this.s)) set(this.s, i = which(abs(this.s[[col]]) > signal.thresh), j = col, value = NA)
        for(col in names(this.s)) set(this.s, i = which(!is.na(this.s[[col]])), j = col, value = 1)
        for(col in names(this.s)) set(this.s, i = which(is.na(this.s[[col]])), j = col, value = 0)
        gc()
        this.germ = this.s[, .(black_list_pct = rowSums(.SD)/dim(this.s)[2])]
        this.germ[, germline.status := ifelse(black_list_pct > pct.thresh, FALSE, TRUE)]
        this.germ = dt2gr(cbind(gr2dt(detergent$template), this.germ))
        detergent$inf_germ = this.germ
      }

      private$pon = detergent

      if (verbose){
        message("Finished making the PON")
      }

      if (save.pon){
        message("Saving PON to the provided path")
        saveRDS(detergent, paste0(path.to.save))
      }
      
    },
    
    start_wash_cycle = function(mc.cores = 1, verbose = TRUE, whole_genome = TRUE, use.blacklist = FALSE, chr = NA, germline.filter = FALSE, germline.file = NA, field = "reads.corrected", is.human = TRUE, all.chr = c(as.character(1:22), "X")){
      
      source("~/git/dryclean/R/helper_functions.R")
      source("~/git/dryclean/R/rrpca.mod2.R")

      
      cov = readRDS(private$cov.path)
      detergent.pon.path = private$pon.path
      
      if(verbose == TRUE){
        message("Loading PON a.k.a detergent from path provided")
      }
      
      if (is.na(detergent.pon.path) & is.null(private$pon)){
        stop('Need pon/detergent file to procced. Use prepare_detergent() command')
      }
      
      if(!is.null(private$pon)){
        rpca.1 = private$pon
      }
      
      if(!is.na(detergent.pon.path) & is.null(private$pon)){
        rpca.1 = readRDS(detergent.pon.path)
      }
      
      if(verbose == TRUE){
        message(paste0("Let's begin, this is whole exome/genome"))
      }
      
      if (germline.filter & is.null(rpca.1$inf_germ)){
        stop("If germiline.filter is set to TRUE, pon must have a inf_germ element, see prepare_detergent for details")
      }
      
      #all.chr = c(as.character(1:22), "X")
      
      is.chr = FALSE
      
      if (is.human){
        if(any(grepl("chr", as.character(seqnames(cov))))){
          cov = gr.sub(cov)
          is.chr = TRUE
        }
        #cov = cov %Q% (seqnames %in% all.chr)
      }
      local.all.chr = all.chr
      cov = cov %Q% (seqnames %in% local.all.chr)
      cov = cov[, field] %>% gr2dt() %>% setnames(., field, "signal") %>% dt2gr()
      cov = sortSeqlevels(cov)
      cov = sort(cov)
      
      m.vec = prep_cov(cov, blacklist = use.blacklist,
                       burnin.samples.path = detergent.pon.path)
      
      m.vec = as.matrix(m.vec$signal)
      L.burnin = rpca.1$L
      S.burnin = rpca.1$S
      r = rpca.1$k
      U.hat = rpca.1$U.hat
      V.hat = rpca.1$V.hat
      sigma.hat = rpca.1$sigma.hat
      
      if(verbose == TRUE){
        message("Initializing wash cycle")
      }
      
      decomposed = wash_cycle(m.vec = m.vec, L.burnin = L.burnin,
                              S.burnin = S.burnin, r = r, U.hat = U.hat,
                              V.hat = V.hat, sigma.hat = sigma.hat)
      
      if (verbose == TRUE){
        message("Combining matrices with gRanges")
      }
      
      cov = gr2dt(cov)
      cov[, median.chr := median(.SD$signal, na.rm = T), by = seqnames]
      
      if (use.blacklist){
        cov[is.na(signal), signal := median.chr]
        cov[is.infinite(signal), signal := median.chr]
        blacklist.pon =  readRDS(paste0(detergent.pon.path, "/blacklist.rds"))
        cov$blacklisted = blacklist.pon$blacklisted
        cov[blacklisted == TRUE, signal := NA]
        cov = na.omit(cov)
      }
      
      setnames(cov, "signal", "input.read.counts")
      cov = cbind(decomposed[[2]], cov)
      colnames(cov)[1] = 'foreground.log'
      cov[is.na(input.read.counts), foreground.log := NA]
      cov[, foreground := exp(foreground.log)]
      cov[input.read.counts == 0, foreground := 0]
      cov[is.na(input.read.counts), foreground := NA]
      cov = cbind(decomposed[[1]], cov)
      colnames(cov)[1] = 'background.log'
      cov[is.na(input.read.counts), background.log := NA]
      cov[, background := exp(background.log) ]
      cov[input.read.counts == 0, background := 0]
      cov[is.na(input.read.counts), background := NA]
      cov[, log.reads := log(input.read.counts)]
      cov[is.infinite(log.reads), log.reads := NA]
      
      if (germline.filter){
        germ.file = rpca.1$inf_germ
        cov$germline.status = germ.file$germline.status
        cov[germline.status == TRUE, foreground := NA]
        cov[germline.status == TRUE, foreground.log := NA]
        cov = na.omit(cov)
      }
      
      cov = dt2gr(cov)
      
      if (is.chr){
        cov = gr.chr(cov)
      }
      private$drycleaned.cov = cov
    },
    
    get_drycleaned_cov = function(){return(private$drycleaned.cov)},
    get_normal_table_path = function(){return(private$normal.table.path)},
    get_normal_table = function(){return(private$normal.table)},
    get_pon_path = function(){return(private$pon.path)},
    get_pon = function(){return(private$pon)},
    get_cov_path = function(){return(private$cov.path)}
    
  )
)




