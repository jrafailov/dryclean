#' @importFrom data.table setkeyv
#' @import GenomicRanges
#' @import rsvd
#' @importFrom MASS ginv
#' @import gUtils
#' @import DNAcopy


##############################
## dryclean R6 object
##############################
#' @name dryclean
#' @title dryclean
#' @description dryclean R6 class storing all methods and values necessary for "drycleaning"
#' @details Add more details 
#' 
#' @export
#' 
#' @author Aditya Deshpande <asd3002@med.cornell.edu>, Sebastian Brylka <sebastian.brylka@nyulangone.org> 


dryclean <- R6::R6Class("dryclean",
    private = list(
      
    normal.table.path = NULL,
    
    normal.table = NULL,
    
    pon.path = NULL,
    
    pon = NULL,
   
    cov.path = NULL,
    
    drycleaned.cov = NULL,
    
    cbs.drycleaned.cov = NULL,
    
    history = NULL,
    
    status = NULL
  ),
  
  public = list(
    
    #' @method initialize() initialize()
    #' @description Initialized dryclean object with given paths to normal table, PON and cov
    #'
    #' @param normal_table_path Character path to data.table containing two columns "sample" and "normal_cov". See manual for details
    #' 
    #' @param pon_path Character path to PON/detergent
    #' @details Can either point to the existing PON or point to the directory where the user wants to save the PON generated by \code{prepare_detergent(save.pon = TRUE)} method
    #' 
    #' @param cov_path Character path to GRanges object containig the GC corrected cov data outputed from fragCounter. Needs metadata with header "reads.corrected"
    initialize = function(normal_table_path = NA, pon_path = NA, cov_path) {
      
      private$history <- data.table(action = character(), date = character())
      private$history <- rbindlist(list(private$history, data.table(action = "Created dryclean object", date = as.character(Sys.time()))))
      
      private$normal.table.path = normal_table_path
      private$pon.path = pon_path
      
      if(is.na(normal_table_path) & is.na(pon_path)){
        stop("Enter normal table path or PON path")
      }

      if(!is.na(normal_table_path)){
        private$normal.table = readRDS(normal_table_path)
        private$history <- rbindlist(list(private$history, data.table(action = paste("Loaded normal table from",normal_table_path), date = as.character(Sys.time()))))
      }

      if(is.na(normal_table_path) & !is.na(pon_path)){
        if (file.exists(private$pon.path)){
          private$pon = readRDS(private$pon.path)
          private$history <- rbindlist(list(private$history, data.table(action = paste("Loaded PON from", pon_path), date = as.character(Sys.time()))))
        } else {
          stop("Warning: PON data file not found or is invalid.")
        }
        
      }

      private$cov.path = cov_path
      
      private$status = "The dryclean class object is created. Recommended next step: "
      
      if(!is.na(normal_table_path) & is.na(pon_path)){
        private$status = paste0(private$status," \n \t Prepare PON aka detergent by using 'prepare_detergent()' method")
      }
      
      if(!is.na(normal_table_path) & !is.na(pon_path)){
        private$status = paste0(private$status," \n \t Prepare and save PON aka detergent by using 'prepare_detergent(save.pon = TRUE)' method")
      }
      
      if(is.na(normal_table_path) & !is.na(pon_path)){
        private$status = paste0(private$status," \n \t Apply dryclean to coverage file by using 'start_wash_cycle()' method")
      }

    },
    
    #' @method prepare_detergent() prepare_detergent()
    #' @description This is the frist stage and involves preparing the Panel of Normals (PON)
    #' that will be used for online decomposition. Author: Aditya Deshpande
    #' @details This function takes in gRanges outputs from fragCounter and extracts GC corrected
    #' read count data and carries rPCA decomposition on the matrix thus created. The normal samples used to form the PON can be selected randomly or by clustering the genomic background or all samples can be used.
    #' 
    #' @param use.all boolean (default == TRUE). If all normal samples are to be used for creating PON.
    #' 
    #' @param choose.randomly boolean (default == FALSE). If a random subset of normal samples are to be used for creating PON.
    #' 
    #' @param choose.by.clustering boolean (default == FALSE). Clusters normal samples based on the genomic background and takes a random sample from within the clusters.
    #' 
    #' @param number.of.samples interger (default == 50). If choose.by.clustering == TRUE, this is the number of clusters at which to cut tree.
    #'
    #' @param tolerance numeric (default == 0.0001). Tolerance for error for batch rPCA. We suggest keeping this value.
    #' 
    #' @param save.pon boolean (default == FALSE). If PON needs to be saved.
    #' 
    #' @param num.cores interger (default == 1). Number of cores to use for parallelization.
    #'
    #' @param verbose boolean (default == TRUE). Outputs progress.
    #'
    #' @param is.human boolean (default == TRUE). Organism type.
    #' 
    #' @param build genome build to define PAR region in chromosome X.
    #'
    #' @param field character (default == "reads.corrected"). Field to use for processing.
    #'
    #' @param PAR.file this is a GRanges with the boundaries of PAR region in X chr.
    #'
    #' @param balance Boolean (default == TRUE) experimental variable to take into consideration 1 copy of X chr in male sample
    #'
    #' @param infer.germline use the L matrix to infer germline events.
    #'
    #' @param signal.thresh numeric (default == 0.5). This is the threshold to be used to identify an amplification (markers with signal intensity > 0.5) or deletions (markers with signal intensity < -0.5) in log space from dryclean outputs.
    #'
    #' @param pct.thresh numeric (default == 0.98). Proportion of samples in which a given marker is free of germline event.
    #'
    #' @param wgs boolean for whether whole genome is being used
    #'
    #' @param target_resolution numeric (default == 1e3) resolution at which to conduct analyses
    #'
    #' @param nochr logical (default = TRUE) remove chr prefix
    #'
    #' @param all.chr list(default = c(as.character(1:22), "X")) list of chromosomes

    prepare_detergent = function(use.all = TRUE, choose.randomly = FALSE, choose.by.clustering = FALSE, number.of.samples = 50, save.pon = FALSE, verbose = TRUE, num.cores = 1, tolerance = 0.0001, is.human = TRUE, build = "hg19", field = "reads.corrected", PAR.file = NULL, balance = TRUE, infer.germline = TRUE, signal.thresh = 0.3, pct.thresh = 0.80, wgs = TRUE, target_resolution = 1000, nochr = TRUE, all.chr = c(as.character(1:22), "X")){

      
      normal.table.path = private$normal.table.path
      path.to.save = private$pon.path

      if (is.na(normal.table.path)){
        stop("Need a table with paths to normal samples to create a PON")
      }

      if (is.na(path.to.save) & save.pon == TRUE){
        stop("Need a path to save decomposed PON")
      }

      if (!is.na(normal.table.path) & !is.na(path.to.save) & save.pon == TRUE){
        message(paste0("WARNING: Creating new PON and saving it at ",path.to.save))
        var = readline(prompt = "Would you like to proceed? Leave the input empty and press Enter to continue, or enter any value to stop ")
        if (var!=""){
          stop("Preparing detergent has been stopped")
        }

      }

      if (verbose){
        message("Starting the preparation of Panel of Normal samples a.k.a detergent")
        private$history <- rbindlist(list(private$history, data.table(action = paste("Started PON preparation"), date = as.character(Sys.time()))))
      }

      normal.table = readRDS(normal.table.path)
      setkeyv(normal.table, "sample")

      num.samp = nrow(normal.table)

      if (verbose){
        message(paste0(num.samp, " samples available"))
      }

      if (use.all & choose.randomly | use.all & choose.by.clustering | choose.randomly & choose.by.clustering | use.all & choose.randomly & choose.by.clustering){
        stop("only one of use.all, choose.randomly, choose.by.clustering can be set to TRUE. Rectify and restart")
      }
      
      if (nochr) {
        template = generate_template(cov = gUtils::gr.nochr(readRDS(normal.table[1]$normal_cov)), wgs = wgs, target_resolution = target_resolution, this.field = field, nochr = nochr, all.chr = all.chr)
      } else {
        template = generate_template(cov = readRDS(normal.table[1]$normal_cov), wgs = wgs, target_resolution = target_resolution, this.field = field, nochr = nochr, all.chr = all.chr)
      }

      if (choose.randomly){
        if (verbose){
          message(paste0("Selecting ", number.of.samples, " normal samples randomly"))
        }
        set.seed(12)
        samp.final = sample(1:num.samp, number.of.samples)
        samp.final = normal.table[samp.final]
        setkey(samp.final, "sample")
      }

      if (choose.by.clustering){

        if (verbose){
          message("Starting the clustering")
        }

        mat.small = mclapply(normal.table[, sample], function(nm){
          this.cov = tryCatch(readRDS(normal.table[nm, normal_cov]), error = function(e) NULL)
          if (!is.null(this.cov)){
            if (nochr) {
              this.cov = gUtils::gr.nochr(this.cov)
            }
            ## this.cov = standardize_coverage(gr.nochr(this.cov), template = template, wgs = wgs, target_resolution = target_resolution, this.field = field)
            this.cov = this.cov[, field] %>% gr2dt() %>% setnames(., field, "signal")
            ## reads = this.cov[seqnames == "22", .(seqnames, signal)]
            reads = this.cov[seqnames == seqnames[1], .(seqnames, signal)]
            reads[, median.chr := median(.SD$signal, na.rm = T), by = seqnames]
            reads[is.na(signal), signal := median.chr]
            min.cov = min(reads[signal > 0]$signal, na.rm = T)
            reads[signal == 0, signal := min.cov]
            reads[signal < 0, signal := min.cov]
            reads = log(reads[, .(signal)])
            reads = transpose(reads)
            reads = cbind(reads, nm)
          } ## else {reads = data.table(NA)}
          return(reads)}, mc.cores = num.cores)

        gc()

        mat.sub = rbindlist(mat.small, fill = T)
        mat.sub = na.omit(mat.sub)
        ix = ncol(mat.sub)
        samp.names = mat.sub[, ..ix]
        mat.sub.t = transpose(mat.sub[, 1:(ncol(mat.sub) - 1)])
        rm(mat.sub)
        gc()

        if (verbose){
          message("Starting decomposition on a small section of genome")
        }

        mat.sub.t = as.matrix(mat.sub.t)
        gc()

        rpca.mat = rrpca.mod(mat.sub.t, tol = tolerance, trace = F)

        rm(mat.sub.t)
        gc()

        if (verbose){
          message("Starting clustering")
        }

        l.mat = rpca.mat$L

        rm(rpca.mat)
        gc()

        l.mat = t(l.mat)
        rownames(l.mat) = samp.names$nm
        clust.out = hclust(dist(l.mat))

        memb = cutree(clust.out, k = number.of.samples)
        memb = setDT(as.data.frame(data.matrix(memb)), keep.rownames = T)

        set.seed(12)
        samp.selected = memb[, .SD[sample(1:.N, 1)], by = V1]$rn
        samp.final = normal.table[samp.selected]
        setkey(samp.final, "sample")
      }

      if (use.all){
        if (verbose){
          message("Using all samples")
        }

        samp.final = normal.table
        setkey(samp.final, "sample")
      }


      if (is.null(PAR.file)){
        if (build == "hg38") {
          message("PAR file not provided, using hg38 default. If this is not the correct build, please provide a GRange object delineating for corresponding build")
          par.path = system.file("extdata", "PAR_hg38.rds", package = 'dryclean')
        } else {
          message("PAR file not provided, using hg19 default. If this is not the correct build, please provide a GRange object delineating for corresponding build")
          par.path = system.file("extdata", "PAR_hg19.rds", package = 'dryclean')
        }
        par.gr = readRDS(par.path)
      } else {par.gr = readRDS(PAR.file)}

      message("PAR read")

      samp.final[, file.available := file.exists(normal_cov)]

      message("Checking for existence of files")

      samp.final = samp.final[file.available == TRUE]

      message(paste0(nrow(samp.final), " files present"))

      mat.n = pbmcapply::pbmclapply(samp.final[, sample], function(nm, all.chr){
        this.cov = tryCatch(readRDS(samp.final[sample == nm, normal_cov]), error = function(e) NULL)
        if (!is.null(this.cov)){
          ## this.cov = standardize_coverage(cov = gr.nochr(this.cov), template = template, wgs = wgs, target_resolution = target_resolution, this.field = field)
          if (nochr) {
            this.cov = gr.nochr(this.cov)
          }
          this.cov = this.cov %Q% (seqnames %in% all.chr)
          this.cov = sortSeqlevels(this.cov)
          this.cov = sort(this.cov)
          this.cov = this.cov[, field] %>% gr2dt() %>% setnames(., field, "signal.org")
          if (balance){
            this.cov[, median.idx := .GRP, by = seqnames]
            this.cov$mt = suppressWarnings(gr.match(dt2gr(this.cov), par.gr))
            this.cov[, median.idx := ifelse(is.na(mt), median.idx, mt+24)]
            this.cov[, median.chr := median(signal.org, na.rm = T), by = median.idx]
            this.cov[, signal := ifelse(seqnames != "X", signal.org,
                                        ifelse(median.chr == 0, 1, signal.org/median.chr))]
          } else {
            this.cov[, signal := signal.org]
            this.cov[, median.chr := median(signal.org, na.rm = T)]
          }
          reads = this.cov[, .(seqnames, signal, median.chr)]
          reads[is.na(signal), signal := median.chr]
          min.cov = min(reads[signal > 0]$signal, na.rm = T)
          reads[is.infinite(signal), signal := min.cov]
          reads[signal == 0, signal := min.cov]
          reads[signal < 0, signal := min.cov]
          reads[, signal := log(signal)]
          reads = reads[, .(signal)]
          if (!any(is.infinite(reads$signal))){
            reads = transpose(reads)
            return(reads)
          }
        }
      }, all.chr, mc.cores = num.cores)
      gc()
      mat.bind = rbindlist(mat.n, fill = T)

      mat.bind.t = transpose(mat.bind)

      rm(mat.bind)
      gc()

      if (verbose){
        message("Starting decomposition")
      }

      mat.bind.t = as.matrix(mat.bind.t)
      gc()

      detergent = rrpca.mod(mat.bind.t, trace = F, tol = tolerance)

      rm(mat.bind.t)
      gc()

      rsvd.L.burnin = rsvd(detergent$L, k = detergent$k)
      detergent$U.hat = rsvd.L.burnin$u
      detergent$V.hat = t(rsvd.L.burnin$v)
      detergent$sigma.hat = rsvd.L.burnin$d
      ##browser()
      ##this.template = readRDS(samp.final[1]$normal_cov)
      ##this.template = sortSeqlevels(this.template)
      ##this.template = sort(this.template)
      ##
      detergent$template = template

      if (infer.germline){
        this.s = as.data.table(detergent$S)
        gc()
        for(col in names(this.s)) set(this.s, i = which(abs(this.s[[col]]) > signal.thresh), j = col, value = NA)
        for(col in names(this.s)) set(this.s, i = which(!is.na(this.s[[col]])), j = col, value = 1)
        for(col in names(this.s)) set(this.s, i = which(is.na(this.s[[col]])), j = col, value = 0)
        gc()
        this.germ = this.s[, .(black_list_pct = rowSums(.SD)/dim(this.s)[2])]
        this.germ[, germline.status := ifelse(black_list_pct > pct.thresh, FALSE, TRUE)]
        this.germ = dt2gr(cbind(gr2dt(detergent$template), this.germ))
        detergent$inf_germ = this.germ
      }

      private$pon = detergent

      if (verbose){
        message("Finished making the PON")
        private$history <- rbindlist(list(private$history, data.table(action = paste("Created new PON from the normal table"), date = as.character(Sys.time()))))
        private$status <- "PON was created and is ready to use. Recommended next step: \n \t Apply dryclean to coverage file by using 'start_wash_cycle()' method"
      }

      if (save.pon){
        message("Saving PON to the provided path")
        saveRDS(detergent, paste0(path.to.save))
        private$history <- rbindlist(list(private$history, data.table(action = paste("Saved new PON at", private$pon.path), date = as.character(Sys.time()))))
        private$status <- "PON was created, saved, and is ready to use. Recommended next step: \n \t Apply dryclean to coverage file by using 'start_wash_cycle()' method"
      }
      
    },
    
    #' @method start_wash_cycle() start_wash_cycle()
    #' @description Function begins the online rPCA process. Use this function if you performed batch rPCA on samples as whole without dividing into chromosomes. For exomes and whole genomes where number of normal samples are small (<=100). Author: Aditya Deshpande 
    #' @details The function begins the online rPCA process. It is the wrapper that takes in GRanges and outputs GRanges with decomposition 
    #' 
    #' @param mc.cores interger (default == 1). Number of cores to use for parallelization.
    #' 
    #' @param detergent.pon.path string. Path to pon/detergent genrated using normal samples.
    #' 
    #' @param whole_genome boolean (default = TRUE). For this function always set this parameter to TRUE.
    #' 
    #' @param use.blacklist boolean (default = FALSE). Whether to exclude off-target markers in case of Exomes or targeted sequencing. If set to TRUE, needs a GRange marking if each marker is set to be excluded or not.
    #'
    #' @param germline.filter boolean (default == FALSE). If germline markers need to be removed from decomposition.
    #'
    #' @param germline.file character (default == NA). Path to file with germline markers.
    #' 
    #' @param verbose boolean (default == TRUE). Outputs progress.
    #' 
    #' @param is.human boolean (default == TRUE). Organism type.
    #' 
    #' @param field character (default == "reads.corrected"). Field to use for processing.
    #' 
    #' @param chr integer (default == NA). Depracated. Can be used to decompose a single chromosome.
    #'
    #' @param all.chr list(default = c(as.character(1:22), "X")) list of chromosomes
    
    start_wash_cycle = function(mc.cores = 1, verbose = TRUE, whole_genome = TRUE, use.blacklist = FALSE, chr = NA, germline.filter = FALSE, germline.file = NA, field = "reads.corrected", is.human = TRUE, all.chr = c(as.character(1:22), "X")){

      
      cov = readRDS(private$cov.path)
      private$history <- rbindlist(list(private$history, data.table(action = paste("Loaded coverage from", private$cov.path), date = as.character(Sys.time()))))
      
      detergent.pon.path = private$pon.path
      
      if(verbose == TRUE){
        message("Loading PON a.k.a detergent from path provided")
      }
      
      if (is.na(detergent.pon.path) & is.null(private$pon)){
        stop('Need pon/detergent file to procced. Use prepare_detergent() command')
      }
      
      if(!is.null(private$pon)){
        rpca.1 = private$pon
      }
      
      if(!is.na(detergent.pon.path) & is.null(private$pon)){
        rpca.1 = readRDS(detergent.pon.path)
        private$history <- rbindlist(list(private$history, data.table(action = paste("Loaded PON from", detergent.pon.path), date = as.character(Sys.time()))))
      }
      
      if(verbose == TRUE){
        message(paste0("Let's begin, this is whole exome/genome"))
      }
      
      private$history <- rbindlist(list(private$history, data.table(action = paste("Started drycleaning coverage file"), date = as.character(Sys.time()))))
      
      if (germline.filter & is.null(rpca.1$inf_germ)){
        stop("If germiline.filter is set to TRUE, pon must have a inf_germ element, see prepare_detergent for details")
      }
      
      #all.chr = c(as.character(1:22), "X")
      
      is.chr = FALSE
      
      if (is.human){
        if(any(grepl("chr", as.character(seqnames(cov))))){
          cov = gr.sub(cov)
          is.chr = TRUE
        }
        #cov = cov %Q% (seqnames %in% all.chr)
      }
      local.all.chr = all.chr
      cov = cov %Q% (seqnames %in% local.all.chr)
      cov = cov[, field] %>% gr2dt() %>% setnames(., field, "signal") %>% dt2gr()
      cov = sortSeqlevels(cov)
      cov = sort(cov)
      
      m.vec = prep_cov(cov, blacklist = use.blacklist,
                       burnin.samples.path = detergent.pon.path)
      
      m.vec = as.matrix(m.vec$signal)
      L.burnin = rpca.1$L
      S.burnin = rpca.1$S
      r = rpca.1$k
      U.hat = rpca.1$U.hat
      V.hat = rpca.1$V.hat
      sigma.hat = rpca.1$sigma.hat
      
      if(verbose == TRUE){
        message("Initializing wash cycle")
      }
      
      decomposed = wash_cycle(m.vec = m.vec, L.burnin = L.burnin,
                              S.burnin = S.burnin, r = r, U.hat = U.hat,
                              V.hat = V.hat, sigma.hat = sigma.hat)
      
      if (verbose == TRUE){
        message("Combining matrices with gRanges")
      }
      
      cov = gr2dt(cov)
      cov[, median.chr := median(.SD$signal, na.rm = T), by = seqnames]
      
      if (use.blacklist){
        cov[is.na(signal), signal := median.chr]
        cov[is.infinite(signal), signal := median.chr]
        blacklist.pon =  readRDS(paste0(detergent.pon.path, "/blacklist.rds"))
        cov$blacklisted = blacklist.pon$blacklisted
        cov[blacklisted == TRUE, signal := NA]
        cov = na.omit(cov)
      }
      
      setnames(cov, "signal", "input.read.counts")
      cov = cbind(decomposed[[2]], cov)
      colnames(cov)[1] = 'foreground.log'
      cov[is.na(input.read.counts), foreground.log := NA]
      cov[, foreground := exp(foreground.log)]
      cov[input.read.counts == 0, foreground := 0]
      cov[is.na(input.read.counts), foreground := NA]
      cov = cbind(decomposed[[1]], cov)
      colnames(cov)[1] = 'background.log'
      cov[is.na(input.read.counts), background.log := NA]
      cov[, background := exp(background.log) ]
      cov[input.read.counts == 0, background := 0]
      cov[is.na(input.read.counts), background := NA]
      cov[, log.reads := log(input.read.counts)]
      cov[is.infinite(log.reads), log.reads := NA]
      
      if (germline.filter){
        germ.file = rpca.1$inf_germ
        cov$germline.status = germ.file$germline.status
        cov[germline.status == TRUE, foreground := NA]
        cov[germline.status == TRUE, foreground.log := NA]
        cov = na.omit(cov)
      }
      
      cov = dt2gr(cov)
      
      if (is.chr){
        cov = gr.chr(cov)
      }
      private$drycleaned.cov = cov
      
      private$history <- rbindlist(list(private$history, data.table(action = paste("Finished drycleaning the coverage file"), date = as.character(Sys.time()))))
      
      private$status <- "The coverage file was drycleaned. Recommended next steps: \n \t Access drycleaned coverage by using 'get_drycleaned_cov()' method \n \t Save drycleaned coverage by using 'save_drycleaned coverage(path)' method \n \t Apply CBS correction to drycleaned coverage by using 'cbs()' method"
      
    },
    
    #' @method cbs() cbs()
    #' @description Function apples CBS correction to the 'drycleaned' GRanges object
    #'
    #' @return Nothing to return
    cbs = function(){
      
      if(is.null(private$drycleaned.cov)){
        stop("Error. The coverage has not been drycleaned yet")
      }
      
      cnsignif = 1e-5
      
      tcov = private$drycleaned.cov
      
      tcov$ratio = values(tcov)[, "foreground"]
      ss.n = NULL
      new.sl = seqlengths(tcov)
      
      if (any(is.na(new.sl)))
      {
        tmp.sl = data.table(sn = as.character(seqnames(tcov)),
                            end = end(tcov))[ , max(end, na.rm = T), by = sn][ ,  structure(V1, names = sn)]
        new.sl[is.na(new.sl)] = tmp.sl[is.na(new.sl)]
        new.sl = new.sl[!is.na(new.sl)]
      }
      

      ix = which(!is.na(tcov$ratio))
      cat('sending ', length(ix), ' segments\n')
      cna = DNAcopy::CNA(log(tcov$ratio[ix]), as.character(seqnames(tcov))[ix], start(tcov)[ix], data.type = 'logratio')
      gc()
      cat('finished making cna\n')
      seg = DNAcopy::segment(DNAcopy::smooth.CNA(cna), alpha = cnsignif, verbose = T) ## 1e-5!!! TODO URGENT
      cat('finished segmenting\n')
      utils::capture.output({seg_dt = print(seg); setDT(seg_dt)}, type = "output", file = "/dev/null") #### KH
      out = gUtils::seg2gr(seg_dt[!(is.na(seg.mean) | is.na(loc.start) | is.na(loc.end))], new.sl) ## remove seqlengths that have not been segmented #### KH
      out = gUtils::gr.fix(out, new.sl, drop = T)
      cat(length(out), ' segments produced\n')
      names(out) = NULL
      private$cbs.drycleaned.cov = out
      gc()
      
      private$history <- rbindlist(list(private$history, data.table(action = paste("Applied CBS correction to the drycleaned coverage file"), date = as.character(Sys.time()))))
    
      private$status <- "The drycleaned coverage file corrected by CBS. Recommended next step: \n \t Save CBS corrected drycleaned coverage by using 'save_cbs_drycleaned_coverage(path)' method"
    },
    
    #' @method get_drycleaned_cov() get_drycleaned_cov()
    #' @description Function returns the 'drycleaned' GRanges object
    #'
    #' @return The 'drycleaned' GRanges object from cov input
    get_drycleaned_cov = function(){return(private$drycleaned.cov)},
    
    #' @method get_cbs_drycleaned_cov() get_cbs_drycleaned_cov()
    #' @description Function returns the CBS corrected 'drycleaned' GRanges object
    #'
    #' @return The CBS corrected 'drycleaned' GRanges object from cov input
    get_cbs_drycleaned_cov = function(){return(private$cbs.drycleaned.cov)},
    
    #' @method get_normal_table_path() get_normal_table_path()
    #' @description Function returns the path to the normal table
    #'
    #' @return Path to the normal table
    get_normal_table_path = function(){return(private$normal.table.path)},
    
    #' @method get_normal_table() get_normal_table()
    #' @description Function returns the normal table
    #'
    #' @return Normal table
    get_normal_table = function(){return(private$normal.table)},
    
    #' @method get_pon_path() get_pon_path()
    #' @description Function returns the path to the PON
    #'
    #' @return Path to the PON
    get_pon_path = function(){return(private$pon.path)},
    
    #' @method get_pon() get_pon()
    #' @description Function returns the PON
    #'
    #' @return PON
    get_pon = function(){return(private$pon)},
    
    #' @method get_cov_path() get_cov_path()
    #' @description Function returns the path to the coverage file
    #'
    #' @return Path to the coverage file
    get_cov_path = function(){return(private$cov.path)},
    
    #' @method get_history() get_history()
    #' @description Function returns the history of the dryclean object
    #'
    #' @return Prints the history of the dryclean object as data table 
    get_history = function(){
      for (i in 1:nrow(private$history)){
        cat(paste0(private$history$date[i], "\t", private$history$action[i], "\n"))
      }
    },
    
    #' @method check_status() check_status()
    #' @description Function returns the current status of the object and recommends next steps
    #'
    #' @return Prints the current status and recommends next actions
    check_status = function(){
      cat(private$status)
    },

    #' @method save_drycleaned_cov(path) save_drycleaned_cov(path)
    #' @description Function saves the drycleaned coverage as rds to the given path
    #'
    #' @param path character(default = NA) path to save rds of the coverage file
    #'
    #' @return Information about save status
    
    save_drycleaned_cov = function(path = NA){
      if(is.null(private$drycleaned.cov)){
        stop("The coverage file has not been drycleaned yet. Use 'start_wash_cycle' method")
      }

      if(is.na(path)){
        stop("Provide the path to save the drycleaned coverage")
      }

      saveRDS(private$drycleaned.cov, path)
      
      private$history <- rbindlist(list(private$history, data.table(action = paste0("Drycleaned coverage file was saved at ",path), date = as.character(Sys.time()))))
      
      private$status <- "The drycleaned coverage file was saved at given path. Recommended next step: \n \t Apply CBS correction to the drycleaned coverage by using 'cbs()' method"
      
      if (file.exists(path)) {
        return("Save successful!")
      } else {
        return("Save failed")
      }
    },
    
    #' @method save_cbs_drycleaned_cov(path) save_cbs_drycleaned_cov(path)
    #' @description Function saves the CBS corrected drycleaned coverage as rds to the given path
    #'
    #' @param path character(default = NA) path to save rds of the cbs coverage file
    #'
    #' @return Information about save status
    
    save_cbs_drycleaned_cov = function(path = NA){
      if(is.null(private$drycleaned.cov)){
        stop("The coverage file has not been drycleaned yet. Use 'start_wash_cycle' method")
      }
      
      if(is.null(private$cbs.drycleaned.cov)){
        stop("CBS has not been applied to the drycleaned coverage file yet. Use 'cbs' method")
      }
      
      if(is.na(path)){
        stop("Provide the path to save the cbs drycleaned coverage")
      }
      
      saveRDS(private$cbs.drycleaned.cov, path)
      
      private$history <- rbindlist(list(private$history, data.table(action = paste0("CBS corrected drycleaned coverage file was saved at ",path), date = as.character(Sys.time()))))
      
      private$status <- "The CBS corrected drycleaned coverage file was saved at given path. Recommended next step: \n \t Access CBS corrected drycleaned coverage by using 'get_cbs_drycleaned_cov()' method"
      
      if (file.exists(path)) {
        return("Save successful!")
      } else {
        return("Save failed")
      }
    }

  )
)




